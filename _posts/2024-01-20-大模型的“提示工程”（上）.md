---
layout:     post   				    # 使用的布局（不需要改）
title:      大模型的“提示工程”（上）   # 标题 
subtitle:   提示工程	                # 副标题
date:       2024-01-20 				# 时间
author:     BY Handx				# 作者
header-img: img/cc0d9b5c75b9440fbe373dd5cb2cb0f8_0.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 提示工程
---

## **本文的目的：**

​		1、帮助开发者学习和应用所需的prompt engineering的最佳实践；

​		2、发现使用LLM的新方法，包括如何构建自定义的聊天机器人；

​		3、获得使用大模型 API的编写和迭代prompt的实践经验。

​	本文的内容，将描述LLM的工作原理，为“提示工程”提供最佳的实践，并展示LLM在各种任务中的应用，包括：

​		**a、**文本摘要：例如简单总结用户评论的摘要；

​		**b、**文本推理：例如情感分类、主题抽取等；

​		**c、**文本转换：例如机器翻译、拼写和语法纠正；

​		**d、**扩展：例如自动编写电子邮件。

​	此外，你还将学习如何编写有效的“prompt”的两个关键原则，如何系统地设计好“prompt”，以及如何构建自定义的聊天机器人。

## **本文背景**

​	本文内容来自于吴恩达的ChatGPT Prompt Engineering（提示工程）课程。

​	课程链接：https://www.deeplearning.ai/short-courses/chatgpt-prompt engineering-for-developers/

​	本文参考：黄杉课程完全笔记 (https://github.com/youcans)

### **1、 两种大语言模型**

​	在大语言模型（LLM）的发展中，可以分为两种类型：基础大语言模型（Base LLM）和指令微调大语言模型（Instruction Tuned LLM）。

#### **1.1 基础大语言模型（Base LLM）**

​	基础大语言模型通常根据来自互联网或其他大型数据集的大量数据进行训练，其工作原理是预测下一个最有可能出现的单词。

​	例如，如果输入“在很久很久以前，有一只神奇的独角兽”，它很有可能会完成这个句子，接下来的预测为“它生活在一个美丽的森林当中”。但是如果输入“法国的首都是哪里？”，那么模型可能会根据互联网上的文章“法国最大的城市是哪里？”、“法国的人口是多少”来完成这项工作，因为互联网上的文章很可能是关于法国的问题列表。

#### **1.2 指令微调语言模型（Instruction Tuned LLM）**

​	指令调优的大语言模型是许多LLM的研究和实践的主要方向。经过指令调优的模型，可以遵循指令来进行预测。因此，当提问“法国的首都是哪里？”，它更有可能回答“法国的首都是巴黎”之类的结果。

​	通常训练指令调优的LLM的方法是：

​		1、首先从已经在大量文本数据训练好的LLM开始进一步训练，具体为使用输入和输出的指令来进行微调（fine-tune）。

​		2、然后使用人类反馈强化学习（RLHF）技术，从人类反馈中进一步改进，使得模型能够更好地遵循人类的指令并提供帮助。

### **2、如何有效的提示**

​	当您使用经过指令调优的LLM时，可以将其想象为向另一个人提供指令，例如向一个聪明但不知道任务具体内容的人提供指令。因此，当LLM无法正常工作时，有时是因为指令不够清晰。例如，如果您说“请撰写一些关于Alan Turing的东西”，除了明确表示您希望文本注重他的科学工作、个人生活、历史角色等方面之外，还需要说明所需文本的风格，例如专业记者的报道或朋友的便签。当然，如果您希望一位刚毕业的大学生来完成此任务，那么甚至可以指定他们预先阅读哪些文本资料，以更好地为成功完成任务做准备。

#### **2.1 指导原则**

 	 a、编写清晰又具体的提示。

  	b、给模型思考时间。

#### **2.2 系统配置**

  	本文以ChatGPT的平替模型claude为例，使用代码来调用slack平台上的claude模型：

```python
import asyncio
from os import getenv
from dotenv import load_dotenv
from slack_sdk.web.async_client import AsyncWebClient
from slack_sdk.errors import SlackApiError

load_dotenv()
CLAUDE_BOT_ID = "member ID"

class SlackClient(AsyncWebClient):
    CHANNEL_ID = None
    LAST_TS = None

    async def chat(self, text):
        if not self.CHANNEL_ID:
            raise Exception("Channel not found.")
        resp = await self.chat_postMessage(channel=self.CHANNEL_ID, text=text)
        # print("c: ", resp)
        self.LAST_TS = resp["ts"]

    async def open_channel(self):
        if not self.CHANNEL_ID:
            # print(111)
            response = await self.conversations_open(users=CLAUDE_BOT_ID)
            self.CHANNEL_ID = response["channel"]["id"]

    async def get_reply(self):
        for _ in range(150):
            try:
                resp = await self.conversations_history(channel=self.CHANNEL_ID, oldest=self.LAST_TS, limit=2)
                # print("r: ", resp)
                pass
                msg = [msg["text"] for msg in resp["messages"] if msg["user"] == CLAUDE_BOT_ID]
                if msg and not msg[-1].endswith("Typing…_"):
                    return msg[-1]
            except (SlackApiError, KeyError) as e:
                # print(f"Get reply error: {e}")
                pass
            await asyncio.sleep(1)
        raise Exception("Get replay timeout")


client = SlackClient(token="token-key")

async def predict(content):
    await client.open_channel()
    await client.chat(content)
    reply = await client.get_reply() 
    print(reply) 
```

#### **2.3 清晰具体的提示**

​	你应提供尽可能清晰而具体的说明，来表达你希望模型去执行的任务。该命令将指导模型生成期望的输出，尽可能减少无关或错误的响应。

**策略一：使用分隔符来清除的表示输入中的不同部分**

```python
if __name__ == "__main__":
  text = f"""您应该通过提供尽可能清晰和具体的说明来表达 \
      您希望模型做什么。这将引导模型获得所需的输出，并减少收到 \
      不相关或不正确响应的机会。不要把写一个清晰的提示和写一个 \
      简短的提示混为一谈。在许多情况下，较长的提示为模型提供了 \
      更多的清晰度和上下文，从而可以产生更详细和相关的输出。"""
      
  prompt = f"将用三个反引号分隔的文本概括为一个句子。'''{text}'''"
  
  loops=asyncio.get_event_loop()
  loops.run_until_complete(asyncio.wait([predict(prompt)]))
```

 	在提示中，我们使用三重反引号将文本括起来，运行这段程序，会获得以下输出：

```bash
您应该通过提供尽可能清晰和具体的说明来表达您希望模型做什么,这可以引导模型产生所需的输出并减少不相关或错误的响应。
```

 	在本样例中，我们使用了这些分隔符，像模型非常清楚地指定它应该使用的确切文本。

​	分隔符可以是任何明确的标点符号，例如三重反引号、单引号、XML标记或者任何一个可以向模型表明这是一个单独部分的符号或标记，例如<>、<tag>等。

 **策略二：要求结构化的输出**

  	为了更容易解析模型的输出，要求结构化输出（html、json等）往往会很有帮助。例如

```python

if __name__ == "__main__":
    prompt = "生成三个虚构的书名及其作者、流派，以json的格式输出，包含以下字段：图书的ID，书名，作者和流派。"
    loops=asyncio.get_event_loop()
    loops.run_until_complete(asyncio.wait([predict(prompt)]))
```

​	  运行以上代码，可以得到以下输出：

```python

 { 
    "id": 1,
    "book_name": "The Forgotten Kingdom", 
    "author": "Mary Williams",
    "genre": "Fantasy"
},
{
    "id": 2, 
    "book_name": "Bittersweet Summer",
     "author": "John Martin", 
    "genre": "Romance" 
},
{
    "id": 3,
    "book_name": "The Spy",
    "author": "Robert Grisham",  
    "genre": "Thriller"
}
```

  **策略三：要求模型检查是否满足条件**

 	如果任务的结果不一定满足假设条件，那么我们可以要求模型先检查这些假设条件，如果不满足，就指出这一点，并停止完成完整的任务。

  	你还可以考虑潜在的边界情况，以及模型如何处理边界情况，以避免意外的错误或结果。

  	例如我们让模型描述一段泡茶的过程：

```python

if __name__ == "__main__":
    text = f"""泡一杯茶很容易！首先，你需要把一些水烧开。\
               在这种情况下，拿一个杯子放一个茶包。一旦水 \
               足够热，就把它倒在茶包上。让它静置一会儿，\
               这样茶就可以变陡了。几分钟后，取出茶包。\
               如果你喜欢，你可以加一些糖或牛奶调味。\
               就这样！你有一杯美味的茶可以享用。"""
    prompt = f"""您将获得由三个引号分隔的文本。\
                如果它包含一系列指令，请按以下格 \
                式重新编写这些指令：
    
                步骤 1 - _
                步骤 2 - _
                _
                步骤 N - _
                如果文本中不包含指令序列，则只需写下“未提供步骤'''{text}'''
                """

    loops=asyncio.get_event_loop()
    loops.run_until_complete(asyncio.wait([predict(prompt)]))
```

 	运行以上代码，可以得到如下结果：

```python

步骤 1 - 拿一个杯子放一个茶包 
步骤 2 - 把一些水烧开
步骤 3 - 一旦水足够热,就把它倒在茶包上
步骤 4 - 让它静置一会儿,这样茶就可以变陡了
步骤 5 - 几分钟后,取出茶包
步骤 6 - 如果你喜欢,你可以加一些糖或牛奶调味
步骤 7 -  就这样!你有一杯美味的茶可以享用
```

​	接下来，我们尝试对不同的段落使用相同的命令。下面这段文字描述了阳光明媚的一天，但是文字中没有任何指令，我们仍使用相同的提示运行以下代码：

```python
if __name__ == "__main__":
    text = f"""今天阳光灿烂，鸟儿在唱歌。今天是去公园散步的好日子。\
          花儿开了，树在微风中轻轻地摇曳。人们四处走动，享受着 \
          宜人的天气。一些人在野餐，而另一些人则在玩游戏或只是在\
          草地上放松。这是一个在户外度过并欣赏大自然之美的完美日\
          子。"""
    prompt = f"""您将获得由三个引号分隔的文本。如果它包含一系列 \
          指令，请按以下格式重新编写这些指令：
          
          步骤 1 - _
          步骤 2 - _
          _
          步骤 N - _
          如果文本中不包含指令序列，则只需写下“未提供步骤'''{text}'''
    """
    
    loops=asyncio.get_event_loop()
    loops.run_until_complete(asyncio.wait([predict(prompt)]))
```

​    运行这段代码，模型确定当前文字中没有指令，其输出结果如下：

```python
 未提供步骤
```

  **策略四：少样本提示（few-shot prompt）**

​	我们最终的目标是少样本（few-shot）提示，即在模型执行实际任务之前，向模型提供执行任务所需要的任务的示例。

​	 例如在下面这个例子中，我们告诉模型，它的任务是以与示例一致的风格回答。

```python

text = f"""<孩子>：教我耐心。

          <奶奶>：雕刻最深山谷的河流来自一个温和的泉水；\
          最伟大的交响乐源于一个音符；最复杂的挂毯是从一根\
          孤零零的线开始的。
      
          <孩子>：教我韧性。"""
    prompt = f"""你的任务是假装<奶奶>回答<孩子>的问题，\
              并保持与<奶奶>的风格一致
              '''{text}'''
              """
    
    loops=asyncio.get_event_loop()
    loops.run_until_complete(asyncio.wait([predict(prompt)]))
```

​	 运行这段代码，得到的输出结果如下：

```python

<奶奶> ：亲爱的孩子,耐心和韧性来自内在。
像河流从泉眼流下,音乐从单音开始,挂毯从一根线编织。
保持内心的平静与定力,方显耐心与韧性。

耐心是一种持之以恒的心态,面对困难不轻言放弃。韧性是一种内在的力量,面对挫折不轻易屈服。
要培养耐心,需学会欣赏过程;要增强韧性,需学会在失败中寻找希望。
我的孩子,用心聆听生活中的一切,体味其中的美好。用心经受生活中的所有,在希望中找到方向。这样,耐心与韧性自然而生,如河入海,日月初升,万事起始
```

​	以上为第一个原则的四种策略，即为模型提供清晰且具体的提示。

#### **2.4 给模型思考的时间**

​    如果模型很匆忙的得出错误的结论，从而导致推理错误，那么你可以重新构建查询，并要求模型根据一系列的推理内容得出最终答案。

​    另外一种情况是，如果给模型一个非常复杂的任务，模型无法在短时间内或用少量文字完成，那么模型极有可能会得出一个不正确的答案。

​    因此，在以上情况下，你可以指示模型更长时间的思考问题。

  **策略1：指定完成任务所需的步骤**

```python
if __name__ == "__main__":
    text = f"""在一个迷人的村庄里，兄弟姐妹杰克和吉尔开始从 \
            山顶的水井取水。当他们高兴地唱着歌往上爬时，不幸降临了。\
            杰克被一块石头绊倒，从山上滚了下来，吉尔也跟着跳了下去。\
            尽管受到了轻微的打击，但两人回到家中，拥抱在一起。\
            尽管遭遇了不幸，他们的冒险精神仍然没有减弱，\
            他们继续愉快地探索。"""
    prompt = f"""执行以下操作：
            1、用一句话总结以下的文本的摘要。
            2、将摘要翻译成英语。
            3、在英语摘要中列出每个名字。
            4、输出一个json对象，其中包含以下关键字：英文摘要、人物数量。
            用换行符分隔你的答案。文本内容为：
            '''{text}'''
            """
    loops=asyncio.get_event_loop()
    loops.run_until_complete(asyncio.wait([predict(prompt)]))
```

​    运行以上代码，你可以很清楚的看到我们已经得到了我们要求的摘要总结、英语翻译以及名字的列表，还有我们要求的json格式，模型输出为：

```python
杰克和吉尔去取水时不幸受伤,但冒险精神不减。

The unfortunate injuries did not curb Jack and Jill's spirit of adventure.  

Jack,Jill

{
    "english_summary": "The unfortunate injuries did not curb Jack and Jill's spirit of adventure.", 
    "num_characters": 2
}
```

​    在上边的例子中的输出会变得不可预测，下面本文会展示另一个提示来完成相同的任务，不同的是，我们要求模型使用指定的格式进行输出。

```python

if __name__ == "__main__":
    text = f"""在一个迷人的村庄里，兄弟姐妹杰克和吉尔开始从山 \
    顶的水井取水。当他们高兴地唱着歌往上爬时，不幸降临了。\
    杰克被一块石头绊倒，从山上滚了下来，吉尔也跟着跳了下去。\
    尽管受到了轻微的打击，但两人回到家中，拥抱在一起。\
    尽管遭遇了不幸，他们的冒险精神仍然没有减弱，\
    他们继续愉快地探索。"""
    prompt = f"""你的任务是执行以下操作：
    1、用一句话总结以下由<>分隔的文本。
    2、将摘要翻译成英文。
    3、在英文摘要中列出每个名字。
    4、输出一个json对象，其中包含以下关键字：英文摘要、人物数量。
    使用以下格式：
    文本：＜要总结的文本＞
    摘要：<文本的摘要>
    翻译：＜翻译后的摘要＞
    姓名：＜英文摘要中的姓名列表＞
    输出JSON:<JSON中包含英文摘要、人物数量>
    文本内容为：'''{text}'''
    """
    loops=asyncio.get_event_loop()
    loops.run_until_complete(asyncio.wait([predict(prompt)]))
```

​	运行以上代码，模型的输出结果如下：

```python
文本:在一个迷人的村庄里,兄弟姐妹杰克和吉尔开始从山顶的水井取水。当他们高兴地唱着歌往上爬时,不幸降临了。杰克被一块石头绊倒,从山上滚了下来,吉尔也跟着跳了下去。尽管受到了轻微的打击,但两人回到家中,拥抱在一起。尽管遭遇了不幸,他们的冒险精神仍然没有减弱,他们继续愉快地探索。

摘要:杰克和吉尔去取水时不幸受伤,但冒险精神不减。

翻译:The unfortunate injuries did not curb Jack and Jill's spirit of adventure.

姓名:Jack,Jill  

输出JSON:{
"english_summary":"The unfortunate injuries did not curb Jack and Jill's spirit of adventure.",
"num_characters":2
```

​	**策略二：教导模型得出结论之前，先自己想办法解决问题**

​	当我们明确只是模型在得出结论之前，先推理出自己的解决方案时，往往会得到更好的结果，即在模型在判断答案正确与否，给模型足够的时间去分析问题，像人类一样。

​	在下面的例子中，我们会要求模型去判断学生的解答是否正确。

```python

if __name__ == "__main__":
    prompt = f"""请判断学生的答案是否正确，不需要解释。
    问题：
    我正在建造一个太阳能装置，我需要帮助来计算财务费用。
    - 土地成本 100 美元/平方英尺
    - 我可以以 250 美元/平方英尺的价格购买太阳能电池板
    - 我协商了一份维护合同，每年将花费我 10 万美元，外加每平方英尺 10 美元
    运营第一年的总成本与平方英尺数的关系是多少？
    学生的解决方案：
    设 x 是以平方英尺为单位的安装尺寸。
    费用：
    1.土地成本：100x
    2.太阳能电池板成本：250x
    3.维护费用：100,000+100x
    总成本：100x + 250x + 100,000 + 100x = 450x +100,000
    """
    loops=asyncio.get_event_loop()
    loops.run_until_complete(asyncio.wait([predict(prompt)]))
```

​	运行以上代码，模型的输出结果如下：

```python
正确
```

​	模型同意学生的观点，因为模型只是粗略的浏览了这行文字，并表明结果是正确的。我们可以通过指导模型首先指定自己的解决方案，然后将该方案与学生的方案与学生的解决方案进行比较，以此来解决这个问题。

~~~python

if __name__ == "__main__":
    prompt = f"""
    你的任务是确定学生的解决方案是否正确。
    要解决此问题，请执行以下操作：
    - 首先，找出你自己的解决方案。
    - 然后将你的解决方案与学生的解决方案进行比较，并评估学生的解决方案是否正确。在你自己完成问题之前，不要判断学生的解决方案是否正确。
    使用以下格式：
    问题：
    ```
    在这里提问
    ```
    学生的解决方案：
    ```
    学生的解决方案在这里
    ```
    实际解决方案：
    ```
    在此处制定解决方案和您的解决方案的步骤
    ```
    学生的解是否与刚刚计算的实际解相同：
    ```
    是或否
    ```
    学生成绩：
    ```
    正确或错误
    ```
    请判断学生的答案是否正确，不需要解释。
    问题：
    ```
    我正在建造一个太阳能装置，我需要帮助来计算财务费用。
    - 土地成本 100 美元/平方英尺
    - 我可以以 250 美元/平方英尺的价格购买太阳能电池板
    - 我协商了一份维护合同，每年将花费我 10 万美元，外加每平方英尺 10 美元
    运营第一年的总成本与平方英尺数的关系是多少？
    ```
    学生的解决方案：
    ```
    设 x 是以平方英尺为单位的安装尺寸。
    费用：
    1.土地成本：100x
    2.太阳能电池板成本：250x
    3.维护费用：100,000+100x
    总成本：100x + 250x + 100,000 + 100x = 450x +100,000
    ```
    实际的解决方案：
    """
    loops=asyncio.get_event_loop()
    loops.run_until_complete(asyncio.wait([predict(prompt)]))
~~~

​	运行以上代码，模型的输出结果如下：

```python
问题:
我正在建造一个太阳能装置,我需要帮助来计算财务费用。
- 土地成本 100 美元/平方英尺  
- 我可以以 250 美元/平方英尺的价格购买太阳能电池板 
- 我协商了一份维护合同,每年将花费我 10 万美元,外加每平方英尺 10 美元
运营第一年的总成本与平方英尺数的关系是多少?

学生的解决方案:  
设 x 是以平方英尺为单位的安装尺寸。
费用:
1.土地成本:100x
2.太阳能电池板成本:250x
3.维护费用:100,000+100x 
总成本:100x + 250x + 100,000 + 100x = 450x +100,000

实际的解决方案:
设x为以平方英尺为单位的安装面积  
费用:
1.土地成本:100x
2.太阳能电池板成本:250x 
3.维护费用:100,000 + 10x(不是100x)
总成本=100x + 250x + 100,000 + 10x = 360x + 100,000

学生的解是否与刚刚计算的实际解相同:
否

学生成绩:
错误
```

​	如结果所示，模型首先进行了自己的计算，并得到了正确答案。然后在被要求将其与学生的解决方案进行比较时，模型意识到结果是不一致的，因此判断学生的结果是不正确的。这个例子说明了要求模型自己进行计算，并将任务拆解，便于为模型提供更多的时间来思考，因此可以帮助你获得更加准确的响应。

#### **2.5 模型的局限性**

​	接下来，我们将讨论模型的局限性，当我们在开发大模型的应用程序时，认识模型的局限性是非常重要的。

​	如果在训练过程中模型面对的知识量非常庞大，它并没有完美地记住它见过的信息，因此它并不是很清楚自己的知识边界。这意味着它可能会试图回答一些关于晦涩话题的问题，并编造听起来可信但实际上并不正确的东西。我们称这些编造的想法为幻觉。

​	我将展示一个例子，在这个例子中，模型会产生幻觉。这是一个例子，模型会编造一个虚构的产品名称描述，产品名称是一个真实的牙刷公司。如果我们运行下面这个提示，“告诉我关于 Boy 公司的 AeroGlide Ultra Slim 智能牙刷”，那么模型将会给出一个相当逼真的虚构产品描述。

```python
if __name__ == "__main__":
    prompt = f"""
    告诉我有关 Boie 的 AeroGlide UltraSlim 智能牙刷的信息
    """
    loops=asyncio.get_event_loop()
    loops.run_until_complete(asyncio.wait([predict(prompt)]))
```

​	模型输出的结果为：

```
Boie 的 AeroGlide UltraSlim 智能牙刷具有以下主要特征:

• 超薄设计:这是一款超薄的电动牙刷,只有 0.2 英寸厚,非常轻便易持。这种超薄和轻便的设计可以提供更加舒适的刷牙体验。

•高效的清洁性能:拥有高达 41,000 次/分钟的高速运动以及全尺寸的清洁组头,可以深入清洁牙齿表面和牙龈线。3D 旋转进行全方位清洁。

• 5种清洁模式:拥有每日清洁、白牙、清新呼吸、indle 和脉冲 5 种模式,可以满足不同的清洁需求。

•定时提醒功能:可设置 2 分钟的刷牙提醒时间,帮助建立良好的刷牙习惯。

• IPX7 防水设计:可以适度防水,方便使用和清洁。但不能长时间浸泡在水中。

•内置锂电池:内置 600mAh 可充电锂电池,充电 2 小时可使用 4 周。

•移动应用配对:可以通过蓝牙与手机应用程序配对,查看刷牙报告和统计,帮助全面了解口腔健康。

•优质服务:产品提供 2 年质保,7*24 小时售后服务。

这些都是 Boie AeroGlide UltraSlim 智能牙刷的主要特征和优势。总体来说,这款产品具有简单超薄的设计、高效的清洁性能以及便利的智能功能,是一款功能齐全而又高性价比的电动牙刷产品。
```

​	这种技术本身存在潜在威胁，因为它听起来相当真实。减少幻觉的一个很好的策略是，如果你想让模型根据文本生成答案，可以要求模型先从文本中找到任何相关引用，然后让它使用这些引用来回答问题，并且把答案追溯到源文件。这种策略通常非常有助于减少模型的幻觉。

  好了，现在你已经掌握提示的指导原则了，在下一节课程中，我们将讲述迭代提示的开发过程。

### **3、 迭代（Iterative）**

​	当使用大语言模型构建应用程序的时候，如果有一个好的迭代过程能够不断改进模型的提示，那么就能找到对实现任务最好的提示词。提示开发是一个迭代的过程，一名好的提示工程师的关键不在于他知道多少完美的提示词，而是使用一个良好的迭代过程来开发提示，使应用更加高效。

​	对于一个应用程序在早期的开发过程中，许多人很有可能只使用一个提示词进行开发，但是对于一个更加成熟的应用程序，使用一组更多的提示可能会更有效。